#!/usr/bin/env python3

import rospy
import numpy as np
import open3d as o3d
import sensor_msgs.point_cloud2 as pc2
from sensor_msgs.msg import Image, CameraInfo, PointCloud2, PointField
from cv_bridge import CvBridge
from ultralytics import YOLO
import message_filters
import struct

class YoloRobustClean:
    def __init__(self):
        rospy.init_node('yolo_robust_clean')
        
        # 1. Config
        self.bridge = CvBridge()
        self.yolo = YOLO('src/best.pt') 
        self.step = 3  # Downsampling step (2 or 3 is good)
        
        # Camera Intrinsics
        self.fx, self.fy, self.cx, self.cy = 600.0, 600.0, 320.0, 240.0
        
        # 2. Publishers
        self.pcl_pub = rospy.Publisher('/yolo/cleaned_cloud', PointCloud2, queue_size=1)
        self.debug_pub = rospy.Publisher('/debug/yolo_box', Image, queue_size=1)

        # 3. Subscribers
        self.info_sub = rospy.Subscriber(
            '/sciurus17/camera/color/camera_info', 
            CameraInfo, self.info_callback
        )
        
        rgb_sub = message_filters.Subscriber('/sciurus17/camera/color/image_raw', Image)
        depth_sub = message_filters.Subscriber('/sciurus17/camera/aligned_depth_to_color/image_raw', Image)
        
        self.ts = message_filters.ApproximateTimeSynchronizer([rgb_sub, depth_sub], 10, 0.1)
        self.ts.registerCallback(self.callback)
        
        rospy.loginfo("Node Ready: Open3D Outlier Removal + Plane Seg + Clustering")

    def info_callback(self, msg):
        k = np.array(msg.K).reshape(3,3)
        self.fx, self.fy, self.cx, self.cy = k[0,0], k[1,1], k[0,2], k[1,2]
        self.info_sub.unregister() 

    def process_with_open3d(self, points, colors):
        """
        The Heavy Lifting:
        1. Statistical Removal (Cleans noise)
        2. Plane Segmentation (Removes Table)
        3. Clustering (Keeps only the cup)
        """
        # Create Open3D Cloud
        pcd = o3d.geometry.PointCloud()
        pcd.points = o3d.utility.Vector3dVector(points)
        pcd.colors = o3d.utility.Vector3dVector(colors / 255.0) # Open3D wants 0-1 RGB

        if len(pcd.points) < 10: return None, None

        # --- STEP A: Statistical Outlier Removal ---
        # Removes points that are further away from their neighbors compared to the average.
        # nb_neighbors: how many neighbors to check (20 is standard)
        # std_ratio: lower = more aggressive removal (1.0 is standard, 0.5 is aggressive)
        pcd, _ = pcd.remove_statistical_outlier(nb_neighbors=20, std_ratio=1.5)

        # --- STEP B: Plane Segmentation (The Table) ---
        # distance_threshold: 0.02 means 2cm. 
        # ransac_n: 3 points to define a plane.
        # num_iterations: 1000 ensures we find the TRUE plane, not a local flat spot on the cup.
        plane_model, inliers = pcd.segment_plane(distance_threshold=0.02,
                                                 ransac_n=3,
                                                 num_iterations=1000)
        
        # If a plane is found, remove it
        if len(inliers) > 0:
            # We only remove the plane if it looks like a table (large enough)
            # If inliers are < 20% of the cloud, it might just be the cup side (don't delete)
            if len(inliers) > 0.2 * len(pcd.points):
                pcd = pcd.select_by_index(inliers, invert=True)

        # --- STEP C: Euclidean Clustering (DBSCAN) ---
        # This groups points that are close to each other.
        # We assume the Cup is the largest chunk remaining.
        # eps: distance to connect points (0.02 = 2cm gap separates objects)
        # min_points: ignore tiny dust clusters
        if len(pcd.points) > 0:
            labels = np.array(pcd.cluster_dbscan(eps=0.03, min_points=20, print_progress=False))
            if labels.max() >= 0: # If at least one cluster exists
                # Find the largest cluster (mode of labels)
                largest_cluster_idx = np.bincount(labels[labels >= 0]).argmax()
                
                # Keep only that cluster
                valid_indices = np.where(labels == largest_cluster_idx)[0]
                pcd = pcd.select_by_index(valid_indices)

        # Convert back to Numpy
        out_points = np.asarray(pcd.points)
        out_colors = np.asarray(pcd.colors) * 255.0 # Back to 0-255
        
        return out_points, out_colors

    def callback(self, rgb_msg, depth_msg):
        try:
            cv_rgb = self.bridge.imgmsg_to_cv2(rgb_msg, "bgr8")
            cv_depth = self.bridge.imgmsg_to_cv2(depth_msg, "16UC1")
        except Exception: return

        # 1. YOLO
        results = self.yolo(cv_rgb, classes=[0], verbose=False, conf=0.4)
        if not results or not results[0].boxes: return

        box = results[0].boxes.xyxy[0].cpu().numpy().astype(int)
        
        # 2. Extract Data
        h, w = cv_depth.shape
        x1, y1 = max(0, box[0]), max(0, box[1])
        x2, y2 = min(w, box[2]), min(h, box[3])

        rgb_roi = cv_rgb[y1:y2:self.step, x1:x2:self.step]
        depth_roi = cv_depth[y1:y2:self.step, x1:x2:self.step]
        
        if depth_roi.size == 0: return

        # 3. Project to 3D
        h_roi, w_roi = depth_roi.shape
        u_col = np.arange(0, w_roi) * self.step + x1
        v_row = np.arange(0, h_roi) * self.step + y1
        u_map, v_map = np.meshgrid(u_col, v_row)

        z = depth_roi.astype(np.float32) / 1000.0 
        valid_mask = (z > 0.1) & (z < 2.0)
        
        if np.count_nonzero(valid_mask) < 10: return

        u_valid = u_map[valid_mask]
        v_valid = v_map[valid_mask]
        z_valid = z[valid_mask]

        x = (u_valid - self.cx) * z_valid / self.fx
        y = (v_valid - self.cy) * z_valid / self.fy
        
        # Stack inputs for Open3D
        xyz_in = np.column_stack((x, y, z_valid))
        
        # Flatten RGB for Open3D
        b = rgb_roi[:, :, 0][valid_mask]
        g = rgb_roi[:, :, 1][valid_mask]
        r = rgb_roi[:, :, 2][valid_mask]
        rgb_in = np.column_stack((r, g, b))

        # ----------------------------------------------------
        # 4. ROBUST OPEN3D CLEANING
        # ----------------------------------------------------
        final_pts, final_cols = self.process_with_open3d(xyz_in, rgb_in)
        
        if final_pts is None or len(final_pts) == 0: return
        # ----------------------------------------------------

        # 5. Pack & Publish
        # Pack colors back to float
        r = final_cols[:, 0].astype(np.uint32)
        g = final_cols[:, 1].astype(np.uint32)
        b = final_cols[:, 2].astype(np.uint32)
        
        rgb_int = (r << 16) | (g << 8) | (b)
        rgb_float = np.array([struct.unpack('f', struct.pack('I', i))[0] for i in rgb_int])
        
        points_3d = np.column_stack((final_pts[:, 0], final_pts[:, 1], final_pts[:, 2], rgb_float))

        fields = [
            PointField('x', 0, PointField.FLOAT32, 1),
            PointField('y', 4, PointField.FLOAT32, 1),
            PointField('z', 8, PointField.FLOAT32, 1),
            PointField('rgb', 12, PointField.FLOAT32, 1),
        ]
        pc_msg = pc2.create_cloud(rgb_msg.header, fields, points_3d)
        self.pcl_pub.publish(pc_msg)

if __name__ == '__main__':
    try:
        YoloRobustClean()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass